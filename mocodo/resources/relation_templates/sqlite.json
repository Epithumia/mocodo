{
  "stem_suffix": "_ddl_sqlite",
  "extension": "sql",
  "to_defer": false,
  "highlight": "sql",
  "transform_data_type": [
    {
      "order": 100,
      "comment": "Fill in empty data types with the default one.",
      "search": "^\\s*$",
      "replace": "VARCHAR(42)"
    }
  ],
  "compose_label_disambiguated_by_note": "{label_before_disambiguation}_{leg_note}",
  "compose_label_disambiguated_by_number": "{label_before_disambiguation}_{disambiguation_number}",
  "compose_primary_key": "{label} {data_type},\nADD_PRIMARY_KEY {label}",
  "compose_alt_primary_key": "{label} {data_type},\nADD_PRIMARY_KEY {label}",
  "compose_alt_normal_attribute": "{label} {data_type}",
  "compose_normal_attribute": "{label} {data_type}",
  "compose_foreign_key": "{label} {data_type},\nADD_FOREIGN_KEY ({label}) REFERENCES {outer_source} ({label_before_disambiguation})",
  "compose_primary_foreign_key": "{label} {data_type},\nADD_PRIMARY_KEY {label},\nADD_FOREIGN_KEY ({label}) REFERENCES {outer_source} ({label_before_disambiguation})",
  "compose_alt_foreign_key": "{label} {data_type},\nADD_FOREIGN_KEY ({label}) REFERENCES {outer_source} ({label_before_disambiguation})",
  "compose_alt_primary_foreign_key": "{label} {data_type},\nADD_PRIMARY_KEY {label},\nADD_FOREIGN_KEY ({label}) REFERENCES {outer_source} ({label_before_disambiguation})",
  "add_unicity_constraints": [
    {
      "order": 100,
      "search": "$",
      "replace": ",\nADD_CONSTRAINT {this_relation_name}_u{unicities} ON {this_relation_name} ({label})"
    }
  ],
  "column_separator": ",\n  ",
  "compose_relation": "CREATE TABLE {this_relation_name} (\n  {columns},\n  PRIMARY KEY ()\n);",
  "transform_relation": [
    {
      "order": 200,
      "comment": "Replace the boolean data type placeholders.",
      "search": " BOOLEAN,\n",
      "replace": " INTEGER,\n"
    },
    {
      "order": 300,
      "comment": "Replace the integer type placeholders.",
      "search": " INTEGER UNSIGNED NOT NULL,\n",
      "replace": " INTEGER NOT NULL,\n"
    },
    {
      "order": 400,
      "comment": "Replace the integer type placeholders.",
      "search": " INTEGER UNSIGNED,\n",
      "replace": " INTEGER,\n"
    },
    {
      "order": 500,
      "comment": "Concatenate the primary keys and move them to the end of the table.",
      "search": "(?sm)ADD_PRIMARY_KEY ([^\n]+)\n(.+?PRIMARY KEY[^\n]+?)\\)",
      "replace": "\\2\\1 )",
      "iterated": true
    },
    {
      "order": 600,
      "search": ", \\)",
      "replace": ")"
    },
    {
      "order": 700,
      "comment": "Move the foreign keys to the end of the table.",
      "search": "(?sm)ADD_FOREIGN_KEY ([^\n]+)\n(.+)^\\)",
      "replace": "\\2  FOREIGN KEY \\1\n)",
      "iterated": true
    },
    {
      "order": 800,
      "comment": "Prefix any 'FOREIGN KEY fk1 REFERENCES T (fk1) \n FOREIGN KEY fk2 REFERENCES T (fk2)' with 'FOREIGN KEY (fk1, fk2) REFERENCES T (fk1, fk2)'",
      "search": "FOREIGN KEY \\((.+?)\\) REFERENCES (.+?) \\((.+?)\\),\n((?:.+\n)*?)  FOREIGN KEY \\((.+?)\\) REFERENCES \\2 \\((.+?)\\),\n",
      "replace": "FOREIGN KEY (\\1, \\5) REFERENCES \\2 (\\3, \\6),\n- FOREIGN KEY (\\1) REFERENCES \\2 (\\3),\n- FOREIGN KEY (\\5) REFERENCES \\2 (\\6),\n\\4",
      "iterated": true
    },
    {
      "order": 900,
      "comment": "Prefix any FOREIGN KEY with a minus sign (mark it as unprotected).",
      "search": "(?m)^  FOREIGN KEY",
      "replace": "- FOREIGN KEY"
    },
    {
      "order": 1000,
      "comment": "Move the constraints to the end of the table.",
      "search": "(?sm)ADD_CONSTRAINT ([^\n]+)\n(.+)^\\)",
      "replace": "\\2  CREATE UNIQUE INDEX \\1\n)",
      "iterated": true
    },
    {
      "order": 1100,
      "search": "(  CREATE UNIQUE INDEX .+_u)(\\d+)(\\d)( ON .+)",
      "replace": "\\1\\2\\4\n\\1\\3\\4",
      "iterated": true
    },
    {
      "order": 1200,
      "comment": "Factorize the UNIQUE constraints.",
      "search": "(?sm)^  CREATE UNIQUE INDEX (.+?) ON (.+?) \\((.+?)\\),\n((?:.+\n)*?)  CREATE UNIQUE INDEX \\1 ON \\2 \\((.+?)\\),\n",
      "replace": "  CREATE UNIQUE INDEX \\1 ON \\2 (\\3, \\5)\n\\4",
      "iterated": true
    }
  ],
  "relation_separator": "\n\n",
  "compose_relational_schema": ".open {title};\n\n{relations}",
  "transform_relational_schema": [
    {
      "order": 100,
      "comment": "Suppress the minus sign before any FOREIGN KEY line which references an actual PRIMARY KEY declared BEFORE this line.",
      "search": "(?m)^(CREATE TABLE (.+) \\(\n((?:.+\n)*)^  PRIMARY KEY (.+)\n((?:.*\n)*))-( FOREIGN KEY .+ REFERENCES \\2 \\4)",
      "replace": "\\1 \\6",
      "iterated": true
    },
    {
      "order": 200,
      "comment": "Suppress the minus sign before any FOREIGN KEY line which references an actual PRIMARY KEY declared AFTER this line.",
      "search": "(?m)^-( FOREIGN KEY .+ REFERENCES ([^\\(]+?) (.+),\n(?:.*\n)*CREATE TABLE \\2 \\(\n(?:.+\n)*^  PRIMARY KEY \\3\n)",
      "replace": " \\1",
      "iterated": true
    },
    {
      "order": 300,
      "comment": "Suppress any unprotected line (still starting with a minus sign).",
      "search": "(?m)^-.+\n",
      "replace": ""
    },
    {
      "order": 400,
      "comment": "Comment out foreign keys referencing commented tables above.",
      "search": "(?sm)(/\\*\nCREATE TABLE (.+?) \\(\n.*^  )(FOREIGN KEY [^\n]+ REFERENCES \\2)",
      "replace": "\\1-- \\3",
      "iterated": true
    },
    {
      "order": 500,
      "comment": "Comment out foreign keys referencing commented tables below.",
      "search": "(?m)^  (FOREIGN KEY .+ REFERENCES (.+?) \\(.+\n(?:.*\n)*/\\*\nCREATE TABLE \\2 \\()",
      "replace": "  -- \\1",
      "iterated": true
    },
    {
      "order": 550,
      "comment": "Move all constraints to the end of the document.",
      "search": "(?sm)(CREATE TABLE .+?)  (CREATE UNIQUE INDEX [^\n]+?),?\n(.*)",
      "replace": "\\1\\3\n\\2;",
      "iterated": true
    },
    {
      "order": 570,
      "search": "(?sm)^(CREATE UNIQUE INDEX .+)",
      "replace": "\n\\1"
    },
    {
      "order": 600,
      "search": ",\n\\)",
      "replace": "\n)"
    },
    {
      "order": 700,
      "comment": "Ensure commented out foreign keys don't leave any orphan comma on the previous line.",
      "search": ",\n  --(.+\\)\n)",
      "replace": "\n  --,\\1",
      "iterated": true
    },
    {
      "order": 800,
      "search": "\n+$",
      "replace": ""
    }
  ]
}